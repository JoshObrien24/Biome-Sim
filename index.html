<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biome Climate Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
        }
        #main-view {
            width: 75%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
        }
        #header {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border: 1px solid rgba(255,255,255,0.1);
        }
        h1 {
            margin: 0;
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        #controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            background: #22c55e;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            transform: scale(1.05);
        }
        button.pause {
            background: #ef4444;
        }
        button.reset {
            background: #3b82f6;
        }
        #canvas-container {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.1);
        }
        canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        #weather-bar {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            display: flex;
            gap: 30px;
            border: 1px solid rgba(255,255,255,0.1);
            color: #ffffff;
        }
        .stat {
            display: flex;
            flex-direction: column;
        }
        .stat-label {
            font-size: 11px;
            opacity: 0.6;
            margin-bottom: 4px;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
        }
        #data-panel {
            width: 25%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            border-left: 2px solid rgba(255,255,255,0.1);
            overflow-y: auto;
        }
        .panel-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        h3 {
            color: #ffffff;
            margin: 0 0 15px 0;
            font-size: 14px;
            letter-spacing: 1px;
        }
        .species-bar {
            margin-bottom: 12px;
        }
        .species-info {
            display: flex;
            justify-content: space-between;
            color: #ffffff;
            font-size: 12px;
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            transition: width 0.5s ease-out;
        }
        #speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ffffff;
        }
        input[type="range"] {
            width: 100px;
        }
        .speed-label {
            font-size: 12px;
            min-width: 40px;
        }
        .import-label {
            cursor: pointer;
        }
        .import-label button {
            pointer-events: none;
        }
        .biome-preset {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 10px;
            color: #ffffff;
            cursor: pointer;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            margin-bottom: 8px;
            transition: background 0.2s;
        }
        .biome-preset:hover {
            background: rgba(255,255,255,0.2);
        }
        #biome-presets {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="main-view">
            <div id="header">
                <h1 id="biome-name">Arctic Taiga</h1>
                <div id="controls">
                    <button id="playBtn">‚ñ∂ PLAY</button>
                    <button id="resetBtn" class="reset">‚Üª RESET</button>
                    <button id="exportBtn" class="reset">üíæ EXPORT</button>
                    <label for="importFile" class="import-label">
                        <button class="reset">üìÅ IMPORT</button>
                    </label>
                    <input type="file" id="importFile" accept=".json" style="display: none;">
                    <div id="speed-control">
                        <span>‚ö°</span>
                        <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
                        <span class="speed-label" id="speedLabel">1.0x</span>
                    </div>
                </div>
            </div>
            <div id="canvas-container">
                <canvas id="mainCanvas" width="800" height="450"></canvas>
            </div>
            <div id="weather-bar">
                <div class="stat">
                    <div class="stat-label">TEMPERATURE</div>
                    <div class="stat-value" id="temp">-15.0¬∞C</div>
                </div>
                <div class="stat">
                    <div class="stat-label">WEATHER</div>
                    <div class="stat-value" id="weather">CLEAR</div>
                </div>
                <div class="stat">
                    <div class="stat-label">WIND</div>
                    <div class="stat-value" id="wind">15.0 km/h</div>
                </div>
                <div class="stat">
                    <div class="stat-label">HUMIDITY</div>
                    <div class="stat-value" id="humidity">65%</div>
                </div>
            </div>
        </div>
        <div id="data-panel">
            <div class="panel-section">
                <h3>QUICK LOAD BIOMES</h3>
                <div id="biome-presets">
                    <button class="biome-preset" data-biome="arctic">Arctic Taiga</button>
                    <button class="biome-preset" data-biome="rainforest">Tropical Rainforest</button>
                    <button class="biome-preset" data-biome="savanna">African Savanna</button>
                </div>
            </div>
            <div class="panel-section">
                <h3>CURRENT POPULATIONS</h3>
                <div id="populations"></div>
            </div>
        </div>
    </div>

    <script>
        // Default biome config
        const DEFAULT_BIOME = {
          name: "Arctic Taiga",
          geography: { latitude: 65, elevation: 200, terrainType: "forest" },
          climate: {
            baseTemp: -15, tempRange: 35, seasonalVariation: 0.8,
            precipitationRate: 0.3, windSpeed: 15, humidity: 0.65
          },
          flora: [
            { type: "spruce", density: 0.4, color: "#2d5016" },
            { type: "pine", density: 0.3, color: "#3a6b35" },
            { type: "shrub", density: 0.5, color: "#4a7c59" }
          ],
          fauna: [
            { species: "caribou", population: 50, growthRate: 0.05, color: "#8b7355", size: 8, speed: 2, diet: "herbivore", animalType: "large_herbivore" },
            { species: "wolf", population: 8, growthRate: 0.02, color: "#505050", size: 6, speed: 3, diet: "carnivore", preyOn: ["caribou"], animalType: "predator" },
            { species: "hare", population: 120, growthRate: 0.15, color: "#d4d4d4", size: 3, speed: 4, diet: "herbivore", animalType: "small_herbivore" },
            { species: "fox", population: 15, growthRate: 0.08, color: "#c1440e", size: 5, speed: 3.5, diet: "carnivore", preyOn: ["hare"], animalType: "predator" }
          ]
        };

        const RAINFOREST_BIOME = {
          name: "Tropical Rainforest",
          geography: { latitude: 5, elevation: 100, terrainType: "jungle" },
          climate: {
            baseTemp: 26, tempRange: 8, seasonalVariation: 0.3,
            precipitationRate: 0.7, windSpeed: 8, humidity: 0.85
          },
          flora: [
            { type: "canopy", density: 0.6, color: "#2d5a2d" },
            { type: "palm", density: 0.4, color: "#3d7a3d" },
            { type: "undergrowth", density: 0.8, color: "#4d9a4d" }
          ],
          fauna: [
            { species: "jaguar", population: 12, growthRate: 0.03, color: "#d4a017", size: 7, speed: 3.5, diet: "carnivore", preyOn: ["capybara", "tapir"], animalType: "predator" },
            { species: "capybara", population: 80, growthRate: 0.1, color: "#8b6f47", size: 6, speed: 2.5, diet: "herbivore", animalType: "large_herbivore" },
            { species: "macaw", population: 150, growthRate: 0.12, color: "#ff4500", size: 4, speed: 5, diet: "herbivore", animalType: "bird" },
            { species: "tapir", population: 40, growthRate: 0.06, color: "#5c4033", size: 7, speed: 2, diet: "herbivore", animalType: "large_herbivore" },
            { species: "anaconda", population: 20, growthRate: 0.04, color: "#556b2f", size: 5, speed: 2, diet: "carnivore", preyOn: ["capybara"], animalType: "predator" },
            { species: "monkey", population: 100, growthRate: 0.1, color: "#8b4513", size: 4, speed: 3, diet: "omnivore", preyOn: ["macaw"], animalType: "small_omnivore" }
          ]
        };

        const SAVANNA_BIOME = {
          name: "African Savanna",
          geography: { latitude: -10, elevation: 800, terrainType: "grassland" },
          climate: {
            baseTemp: 24, tempRange: 15, seasonalVariation: 0.6,
            precipitationRate: 0.2, windSpeed: 12, humidity: 0.5
          },
          flora: [
            { type: "acacia", density: 0.2, color: "#8b7355" },
            { type: "grass", density: 0.9, color: "#9acd32" },
            { type: "baobab", density: 0.05, color: "#a0826d" }
          ],
          fauna: [
            { species: "lion", population: 10, growthRate: 0.025, color: "#daa520", size: 8, speed: 4, diet: "carnivore", preyOn: ["zebra", "wildebeest"], animalType: "predator" },
            { species: "zebra", population: 100, growthRate: 0.08, color: "#000000", size: 7, speed: 4.5, diet: "herbivore", animalType: "large_herbivore" },
            { species: "wildebeest", population: 150, growthRate: 0.09, color: "#696969", size: 7, speed: 4, diet: "herbivore", animalType: "large_herbivore" },
            { species: "cheetah", population: 8, growthRate: 0.02, color: "#ffd700", size: 6, speed: 6, diet: "carnivore", preyOn: ["gazelle"], animalType: "predator" },
            { species: "gazelle", population: 120, growthRate: 0.1, color: "#d2b48c", size: 5, speed: 5.5, diet: "herbivore", animalType: "small_herbivore" },
            { species: "elephant", population: 30, growthRate: 0.03, color: "#808080", size: 12, speed: 2, diet: "herbivore", animalType: "large_herbivore" },
            { species: "baboon", population: 60, growthRate: 0.09, color: "#a0522d", size: 5, speed: 3, diet: "omnivore", preyOn: ["gazelle"], animalType: "small_omnivore" }
          ]
        };

        // Simulation class
        class BiomeSimulation {
            constructor(config) {
                this.config = JSON.parse(JSON.stringify(config));
                this.time = 0;
                this.dayOfYear = 0;
                this.temperature = 0;
                this.precipitation = 0;
                this.wind = 0;
                this.humidity = 0;
                this.season = "winter";
                this.weather = "clear";
                this.animals = [];
                this.initializeAnimals();
            }

            initializeAnimals() {
                this.animals = [];
                this.config.fauna.forEach(species => {
                    for (let i = 0; i < species.population; i++) {
                        this.animals.push({
                            id: `${species.species}_${i}`,
                            species: species.species,
                            x: Math.random() * 800,
                            y: Math.random() * 450,
                            vx: (Math.random() - 0.5) * species.speed,
                            vy: (Math.random() - 0.5) * species.speed,
                            color: species.color,
                            size: species.size,
                            speed: species.speed,
                            diet: species.diet,
                            preyOn: species.preyOn || [],
                            animalType: species.animalType || "default",
                            energy: 100,
                            age: Math.random() * 50
                        });
                    }
                });
            }

            getSeason(dayOfYear) {
                if (dayOfYear < 90) return "winter";
                if (dayOfYear < 180) return "spring";
                if (dayOfYear < 270) return "summer";
                if (dayOfYear < 360) return "autumn";
                return "winter";
            }

            calculateTemperature(dayOfYear) {
                const { baseTemp, tempRange, seasonalVariation } = this.config.climate;
                const yearProgress = (dayOfYear / 365) * 2 * Math.PI;
                const seasonalTemp = Math.sin(yearProgress - Math.PI / 2) * tempRange * seasonalVariation;
                const dailyVariation = (Math.random() - 0.5) * 5;
                return baseTemp + seasonalTemp + dailyVariation;
            }

            calculateWeather(temp) {
                const precipChance = this.config.climate.precipitationRate;
                const rand = Math.random();
                if (rand < precipChance) return temp < 0 ? "snow" : "rain";
                if (rand < precipChance * 1.5) return "cloudy";
                return "clear";
            }

            updateAnimals() {
                this.animals.forEach(animal => {
                    animal.age += 0.01;
                    animal.energy -= 0.1;
                    animal.vx += (Math.random() - 0.5) * 0.2;
                    animal.vy += (Math.random() - 0.5) * 0.2;

                    const maxSpeed = animal.speed;
                    const currentSpeed = Math.sqrt(animal.vx ** 2 + animal.vy ** 2);
                    if (currentSpeed > maxSpeed) {
                        animal.vx = (animal.vx / currentSpeed) * maxSpeed;
                        animal.vy = (animal.vy / currentSpeed) * maxSpeed;
                    }

                    animal.x += animal.vx;
                    animal.y += animal.vy;

                    if (animal.x < 0) animal.x = 800;
                    if (animal.x > 800) animal.x = 0;
                    if (animal.y < 0) animal.y = 450;
                    if (animal.y > 450) animal.y = 0;
                });

                // Predation
                this.animals.forEach(predator => {
                    if ((predator.diet === "carnivore" || predator.diet === "omnivore") && predator.preyOn.length > 0) {
                        this.animals.forEach(prey => {
                            if (predator.preyOn.includes(prey.species)) {
                                const dx = predator.x - prey.x;
                                const dy = predator.y - prey.y;
                                const distance = Math.sqrt(dx ** 2 + dy ** 2);

                                if (distance < 20) {
                                    predator.vx = -dx / distance * predator.speed;
                                    predator.vy = -dy / distance * predator.speed;

                                    if (distance < 10 && Math.random() < 0.1) {
                                        prey.energy = 0;
                                        predator.energy = Math.min(100, predator.energy + 50);
                                    }
                                }
                            }
                        });
                    }
                });

                this.animals = this.animals.filter(a => a.energy > 0 && a.age < 100);

                // Reproduction
                const speciesCounts = {};
                this.animals.forEach(a => speciesCounts[a.species] = (speciesCounts[a.species] || 0) + 1);

                this.config.fauna.forEach(species => {
                    const currentPop = speciesCounts[species.species] || 0;
                    if (currentPop < species.population && Math.random() < species.growthRate) {
                        this.animals.push({
                            id: `${species.species}_${Date.now()}_${Math.random()}`,
                            species: species.species,
                            x: Math.random() * 800,
                            y: Math.random() * 450,
                            vx: (Math.random() - 0.5) * species.speed,
                            vy: (Math.random() - 0.5) * species.speed,
                            color: species.color,
                            size: species.size,
                            speed: species.speed,
                            diet: species.diet,
                            preyOn: species.preyOn || [],
                            animalType: species.animalType || "default",
                            energy: 100,
                            age: 0
                        });
                    }
                });
            }

            step(hoursPerStep = 1) {
                this.time += hoursPerStep;
                this.dayOfYear = Math.floor(this.time / 24) % 365;
                this.season = this.getSeason(this.dayOfYear);
                this.temperature = this.calculateTemperature(this.dayOfYear);
                this.weather = this.calculateWeather(this.temperature);
                this.wind = this.config.climate.windSpeed + (Math.random() - 0.5) * 10;
                this.humidity = this.config.climate.humidity + (Math.random() - 0.5) * 0.2;
                this.precipitation = this.weather === "rain" || this.weather === "snow" ? Math.random() * 10 : 0;
                this.updateAnimals();
            }
        }

        // App State
        let simulation = new BiomeSimulation(DEFAULT_BIOME);
        let isPlaying = false;
        let speed = 1;
        let animationId = null;
        let frameCount = 0;
        let uiUpdateInterval = 10; // Update UI every 10 frames for faster refresh
        
        // Smooth background color transitions
        let currentBgColor = { r: 212, g: 233, b: 247 }; // Start with winter color
        let targetBgColor = { r: 212, g: 233, b: 247 };

        // Canvas setup with double buffering
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for performance
        ctx.imageSmoothingEnabled = false; // Pixel art style
        
        // Offscreen canvas for double buffering (eliminates flashing)
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = 800;
        offscreenCanvas.height = 450;
        const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });
        offscreenCtx.imageSmoothingEnabled = false; // Pixel art style

        // Render functions
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function getTargetBackgroundColor(season, weather) {
            if (weather === "snow") return hexToRgb("#e8f4f8");
            if (weather === "rain") return hexToRgb("#b0c4de");
            if (weather === "cloudy") return hexToRgb("#c0d6e8");
            switch(season) {
                case "winter": return hexToRgb("#d4e9f7");
                case "spring": return hexToRgb("#c8e6c9");
                case "summer": return hexToRgb("#f0f4c3");
                case "autumn": return hexToRgb("#ffe0b2");
                default: return hexToRgb("#e0e0e0");
            }
        }

        function interpolateColor(current, target, speed = 0.05) {
            return {
                r: current.r + (target.r - current.r) * speed,
                g: current.g + (target.g - current.g) * speed,
                b: current.b + (target.b - current.b) * speed
            };
        }

        function rgbToString(rgb) {
            return `rgb(${Math.floor(rgb.r)}, ${Math.floor(rgb.g)}, ${Math.floor(rgb.b)})`;
        }

        function getBackgroundColor(season, weather) {
            if (weather === "snow") return "#e8f4f8";
            if (weather === "rain") return "#b0c4de";
            if (weather === "cloudy") return "#c0d6e8";
            switch(season) {
                case "winter": return "#d4e9f7";
                case "spring": return "#c8e6c9";
                case "summer": return "#f0f4c3";
                case "autumn": return "#ffe0b2";
                default: return "#e0e0e0";
            }
        }

        function drawWeather(drawCtx, weather, intensity) {
            if (weather === "snow" || weather === "rain") {
                drawCtx.fillStyle = weather === "snow" ? "rgba(255,255,255,0.8)" : "rgba(100,149,237,0.6)";
                const particleCount = Math.floor(intensity * 12);
                for (let i = 0; i < particleCount; i++) {
                    const seed = i + Math.floor(simulation.time * 0.1);
                    const x = Math.floor((seed * 137.508) % 800);
                    const y = Math.floor(((seed * 197.508) + (simulation.time * 2)) % 450);
                    if (weather === "snow") {
                        drawCtx.fillRect(x, y, 4, 4); // Bigger snowflakes
                    } else {
                        drawCtx.fillRect(x, y, 2, 10); // Rain streaks
                    }
                }
            }
        }

        function drawTerrain(drawCtx, flora, season) {
            flora.forEach(plant => {
                const count = Math.floor(plant.density * 50);
                for (let i = 0; i < count; i++) {
                    const x = Math.floor((i * 137.508) % 800);
                    const y = Math.floor((i * 197.508) % 450);

                    let color = plant.color;
                    if (season === "autumn") color = "#d4a574";
                    if (season === "winter") color = "#7a9b8e";

                    drawCtx.fillStyle = color;

                    if (plant.type === "spruce" || plant.type === "pine") {
                        // Pixelated tree
                        drawCtx.fillRect(x - 2, y + 5, 4, 8); // trunk
                        drawCtx.fillRect(x - 8, y - 5, 16, 10); // foliage bottom
                        drawCtx.fillRect(x - 6, y - 12, 12, 7); // foliage middle
                        drawCtx.fillRect(x - 4, y - 16, 8, 4); // foliage top
                    } else if (plant.type === "acacia" || plant.type === "baobab") {
                        // Flat-top tree
                        drawCtx.fillRect(x - 2, y, 4, 12); // trunk
                        drawCtx.fillRect(x - 10, y - 8, 20, 8); // flat canopy
                    } else if (plant.type === "palm" || plant.type === "canopy") {
                        // Palm tree
                        drawCtx.fillRect(x - 1, y, 2, 12); // thin trunk
                        drawCtx.fillRect(x - 8, y - 4, 16, 4); // leaves
                    } else {
                        // Shrub/grass - just pixel clusters
                        drawCtx.fillRect(x - 2, y - 2, 4, 4);
                        drawCtx.fillRect(x + 2, y, 3, 3);
                        drawCtx.fillRect(x - 3, y + 1, 3, 3);
                    }
                }
            });
        }

        function render() {
            // Draw everything to the offscreen canvas first
            const drawCtx = offscreenCtx;
            
            // Smoothly interpolate background color
            targetBgColor = getTargetBackgroundColor(simulation.season, simulation.weather);
            currentBgColor = interpolateColor(currentBgColor, targetBgColor, 0.05);
            
            // Clear canvas with smoothly transitioning background
            drawCtx.fillStyle = rgbToString(currentBgColor);
            drawCtx.fillRect(0, 0, 800, 450);

            // Draw terrain first (static elements)
            drawTerrain(drawCtx, simulation.config.flora, simulation.season);

            // Draw weather effects (before animals so they're behind)
            drawWeather(drawCtx, simulation.weather, simulation.precipitation);

            // Draw animals as pixel art sprites
            simulation.animals.forEach(animal => {
                drawPixelAnimal(drawCtx, animal);
            });

            // Draw time/season overlay
            drawCtx.fillStyle = 'rgba(0,0,0,0.7)';
            drawCtx.fillRect(10, 10, 220, 50);
            drawCtx.fillStyle = '#ffffff';
            drawCtx.font = 'bold 16px "Courier New", monospace';
            drawCtx.fillText(`Day ${Math.floor(simulation.dayOfYear)} - ${simulation.season.toUpperCase()}`, 20, 30);
            drawCtx.font = '14px "Courier New", monospace';
            drawCtx.fillText(`Time: ${Math.floor(simulation.time % 24)}:00`, 20, 50);
            
            // Copy the complete offscreen canvas to the visible canvas in one operation
            // Don't clear first - just overwrite
            ctx.drawImage(offscreenCanvas, 0, 0);
        }

        // Pixel art animal drawing function - uses animalType instead of species names
        function drawPixelAnimal(drawCtx, animal) {
            const x = Math.floor(animal.x);
            const y = Math.floor(animal.y);
            const size = animal.size;
            const type = animal.animalType || "default";
            
            // Draw pixel art style animal based on animalType
            drawCtx.fillStyle = animal.color;
            
            switch(type) {
                case "large_herbivore":
                    // Large herbivore - blocky body (caribou, elephant, wildebeest, zebra)
                    drawCtx.fillRect(x - size, y - size/2, size * 2, size);
                    drawCtx.fillRect(x - size/2, y - size * 1.5, size, size); // head
                    // legs
                    drawCtx.fillRect(x - size, y + size/2, size/3, size/2);
                    drawCtx.fillRect(x + size/2, y + size/2, size/3, size/2);
                    break;
                    
                case "small_herbivore":
                    // Small herbivore - compact (hare, gazelle)
                    drawCtx.fillRect(x - size/2, y - size/2, size, size);
                    drawCtx.fillRect(x - size/3, y - size, size/3, size/2); // ear
                    break;
                    
                case "predator":
                    // Predator - sleeker (wolf, fox, lion, jaguar, cheetah, anaconda)
                    drawCtx.fillRect(x - size, y - size/3, size * 1.5, size * 0.6);
                    drawCtx.fillRect(x + size/2, y - size/2, size/2, size/2); // head
                    // tail
                    drawCtx.fillRect(x - size * 1.5, y, size/2, size/3);
                    break;
                    
                case "bird":
                    // Bird - triangular (macaw)
                    drawCtx.beginPath();
                    drawCtx.moveTo(x, y - size);
                    drawCtx.lineTo(x - size, y + size/2);
                    drawCtx.lineTo(x + size, y + size/2);
                    drawCtx.closePath();
                    drawCtx.fill();
                    break;
                    
                case "small_omnivore":
                    // Small omnivore - rounded compact (monkey, baboon)
                    drawCtx.fillRect(x - size/2, y - size/2, size, size * 1.2);
                    drawCtx.fillRect(x - size/3, y - size, size * 0.6, size * 0.5); // head
                    // arms
                    drawCtx.fillRect(x - size, y, size/3, size/2);
                    drawCtx.fillRect(x + size * 0.6, y, size/3, size/2);
                    // tail
                    drawCtx.fillRect(x + size/4, y + size, size/4, size);
                    break;
                    
                default:
                    // Default - simple square
                    drawCtx.fillRect(x - size/2, y - size/2, size, size);
                    break;
            }
            
            // Add eye dot
            drawCtx.fillStyle = '#000000';
            const eyeX = x + (animal.vx > 0 ? size/3 : -size/3);
            drawCtx.fillRect(eyeX, y - size/3, 2, 2);
            
            // Direction indicator (different colors for different diets)
            if (animal.diet === 'carnivore') {
                drawCtx.strokeStyle = 'rgba(255,0,0,0.4)';
            } else if (animal.diet === 'omnivore') {
                drawCtx.strokeStyle = 'rgba(255,165,0,0.4)';
            } else {
                return; // No indicator for herbivores
            }
            
            drawCtx.lineWidth = 2;
            drawCtx.beginPath();
            drawCtx.moveTo(x, y);
            drawCtx.lineTo(x + animal.vx * 2, y + animal.vy * 2);
            drawCtx.stroke();
        }

        function updateUI() {
            // Round values to reduce constant micro-changes
            document.getElementById('temp').textContent = Math.round(simulation.temperature) + '¬∞C';
            document.getElementById('weather').textContent = simulation.weather.toUpperCase();
            document.getElementById('wind').textContent = Math.round(simulation.wind) + ' km/h';
            document.getElementById('humidity').textContent = Math.round(simulation.humidity * 100) + '%';

            // Update populations
            const speciesCounts = {};
            simulation.animals.forEach(a => speciesCounts[a.species] = (speciesCounts[a.species] || 0) + 1);

            const popHTML = simulation.config.fauna.map(species => {
                const count = speciesCounts[species.species] || 0;
                const percent = (count / species.population) * 100;
                return `
                    <div class="species-bar">
                        <div class="species-info">
                            <span>${species.species}</span>
                            <span>${count}</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percent}%; background: ${species.color};"></div>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('populations').innerHTML = popHTML;
        }

        function gameLoop() {
            if (isPlaying) {
                simulation.step(speed);
                render();
                
                // Only update UI text every N frames to reduce flashing
                frameCount++;
                if (frameCount % uiUpdateInterval === 0) {
                    updateUI();
                }
                
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            const btn = document.getElementById('playBtn');
            btn.textContent = isPlaying ? '‚è∏ PAUSE' : '‚ñ∂ PLAY';
            btn.className = isPlaying ? 'pause' : '';
            if (isPlaying) gameLoop();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            simulation = new BiomeSimulation(DEFAULT_BIOME);
            isPlaying = false;
            document.getElementById('playBtn').textContent = '‚ñ∂ PLAY';
            document.getElementById('playBtn').className = '';
            render();
            updateUI();
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speed = parseFloat(e.target.value);
            document.getElementById('speedLabel').textContent = speed.toFixed(1) + 'x';
        });

        // Export biome configuration
        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataStr = JSON.stringify(simulation.config, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${simulation.config.name.replace(/\s+/g, '_')}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        });

        // Import biome configuration
        document.getElementById('importFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const config = JSON.parse(event.target.result);
                        simulation = new BiomeSimulation(config);
                        isPlaying = false;
                        document.getElementById('playBtn').textContent = '‚ñ∂ PLAY';
                        document.getElementById('playBtn').className = '';
                        document.getElementById('biome-name').textContent = config.name;
                        
                        // Reset color interpolation for new biome
                        const initialColor = getTargetBackgroundColor(simulation.season, simulation.weather);
                        currentBgColor = initialColor;
                        targetBgColor = initialColor;
                        
                        render();
                        updateUI();
                        alert(`Loaded biome: ${config.name}`);
                    } catch (error) {
                        alert('Error loading biome configuration: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
            // Reset file input
            e.target.value = '';
        });

        // Quick load preset biomes
        document.querySelectorAll('.biome-preset').forEach(btn => {
            btn.addEventListener('click', () => {
                const biomeType = btn.getAttribute('data-biome');
                let config;
                
                switch(biomeType) {
                    case 'arctic':
                        config = DEFAULT_BIOME;
                        break;
                    case 'rainforest':
                        config = RAINFOREST_BIOME;
                        break;
                    case 'savanna':
                        config = SAVANNA_BIOME;
                        break;
                    default:
                        return;
                }
                
                simulation = new BiomeSimulation(config);
                isPlaying = false;
                document.getElementById('playBtn').textContent = '‚ñ∂ PLAY';
                document.getElementById('playBtn').className = '';
                document.getElementById('biome-name').textContent = config.name;
                
                // Reset color interpolation for new biome
                const initialColor = getTargetBackgroundColor(simulation.season, simulation.weather);
                currentBgColor = initialColor;
                targetBgColor = initialColor;
                
                render();
                updateUI();
            });
        });

        // Initial render
        render();
        updateUI();
    </script>
</body>
</html>
